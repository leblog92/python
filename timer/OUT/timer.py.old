import time
import datetime
import winsound
import pyttsx3
import threading
from datetime import datetime
import queue

class SessionNotifier:
    def __init__(self):
        self.engine = pyttsx3.init()
        self.running = True
        self.last_announcement = None
        self.announcement_queue = queue.Queue()
        self.tts_lock = threading.Lock()
        
        # Configuration des annonces (heure: (fichier_son, message))
        self.schedule = {
            (14, 0): (None, "D√©but de session"),
            (14, 30): ("son1.wav", "Il reste 30 minutes"),
            (14, 45): ("son1.wav", "Il reste 15 minutes"),
            (14, 50): ("son1.wav", "Il reste 10 minutes"),
            (14, 58): ("son2.wav", "Fin de session"),
            (15, 30): ("son1.wav", "Il reste 30 minutes"),
            (15, 45): ("son1.wav", "Il reste 15 minutes"),
            (15, 50): ("son1.wav", "Il reste 10 minutes"),
            (15, 58): ("son2.wav", "Fin de session"),
            (16, 30): ("son1.wav", "Il reste 30 minutes"),
            (16, 45): ("son1.wav", "Il reste 15 minutes"),
            (16, 50): ("son1.wav", "Il reste 10 minutes"),
            (16, 58): ("son2.wav", "Fin de session"),
            (17, 30): ("son1.wav", "Il reste 30 minutes"),
            (17, 45): ("son1.wav", "Il reste 15 minutes"),
            (17, 50): ("son1.wav", "Il reste 10 minutes"),
            (17, 58): ("son2.wav", "Fin de session")
        }
        
        # D√©marrer le worker de traitement des annonces
        self.worker_thread = threading.Thread(target=self._process_announcements)
        self.worker_thread.daemon = True
        self.worker_thread.start()
        
    def set_voice_hortense(self):
        """Configure la voix Microsoft Hortense"""
        try:
            voices = self.engine.getProperty('voices')
            
            # Chercher Microsoft Hortense
            for voice in voices:
                if "hortense" in voice.name.lower():
                    self.engine.setProperty('voice', voice.id)
                    # Ajuster les param√®tres pour une meilleure qualit√©
                    self.engine.setProperty('rate', 150)  # Vitesse moyenne
                    self.engine.setProperty('volume', 0.9)  # Volume √©lev√©
                    print(f"‚úì Voix configur√©e : {voice.name}")
                    return True
            
            print("‚úó Microsoft Hortense non trouv√©e, utilisation de la voix par d√©faut")
            return False
            
        except Exception as e:
            print(f"Erreur configuration voix : {e}")
            return False
    
    def play_sound(self, sound_file):
        """Joue un fichier WAV"""
        if sound_file:
            try:
                winsound.PlaySound(sound_file, winsound.SND_FILENAME)
                print(f"üîä Son jou√© : {sound_file}")
            except Exception as e:
                print(f"‚ùå Erreur lecture son {sound_file}: {e}")
    
    def speak_text(self, text):
        """Prononce le texte avec la voix synth√©tique (thread-safe)"""
        with self.tts_lock:
            try:
                self.engine.say(text)
                self.engine.runAndWait()
                print(f"üó£Ô∏è Message prononc√© : {text}")
            except RuntimeError as e:
                if "run loop already started" in str(e):
                    # Recr√©er le moteur TTS en cas d'erreur
                    try:
                        self.engine.stop()
                        self.engine = pyttsx3.init()
                        self.set_voice_hortense()
                        self.engine.say(text)
                        self.engine.runAndWait()
                        print(f"üó£Ô∏è Message prononc√© (apr√®s r√©cup√©ration) : {text}")
                    except Exception as e2:
                        print(f"‚ùå Erreur r√©cup√©ration synth√®se vocale : {e2}")
                else:
                    print(f"‚ùå Erreur synth√®se vocale : {e}")
            except Exception as e:
                print(f"‚ùå Erreur synth√®se vocale : {e}")
    
    def _process_announcements(self):
        """Worker thread pour traiter les annonces en s√©quence"""
        while self.running:
            try:
                # Attendre une annonce avec timeout
                announcement = self.announcement_queue.get(timeout=1.0)
                if announcement is None:  # Signal d'arr√™t
                    break
                    
                sound_file, message = announcement
                
                # Jouer le son si pr√©sent
                if sound_file:
                    self.play_sound(sound_file)
                    time.sleep(2.0)  # ‚è±Ô∏è Attend la fin du son
                
                # Prononcer le message
                self.speak_text(message)
                
                self.announcement_queue.task_done()
                
            except queue.Empty:
                continue
            except Exception as e:
                print(f"‚ùå Erreur dans le worker d'annonces : {e}")
    
    def make_announcement(self, sound_file, message):
        """Ajoute une annonce √† la file d'attente"""
        try:
            self.announcement_queue.put((sound_file, message))
            print(f"üì® Annonce ajout√©e √† la file : {message}")
        except Exception as e:
            print(f"‚ùå Erreur ajout annonce √† la file : {e}")
    
    def get_paris_time(self):
        """Retourne l'heure actuelle de Paris"""
        return datetime.now()
    
    def should_announce(self, current_time):
        """V√©rifie si une annonce doit √™tre faite √† l'heure actuelle"""
        current_key = (current_time.hour, current_time.minute)
        
        if current_key in self.schedule:
            announcement_id = f"{current_key}_{current_time.date()}"
            
            # √âviter les annonces r√©p√©t√©es dans la m√™me minute
            if announcement_id != self.last_announcement:
                self.last_announcement = announcement_id
                return True
        
        return False
    
    def run(self):
        """Boucle principale du programme"""
        print("üöÄ D√©marrage du programme de notifications de session")
        print("‚è∞ Fuseau horaire : Paris")
        print("üìÖ Notifications programm√©es :")
        
        for time_key, (sound, message) in sorted(self.schedule.items()):
            print(f"  {time_key[0]:02d}h{time_key[1]:02d} : {message} ({sound if sound else 'pas de son'})")
        
        print("\nüîä Configuration de la voix...")
        self.set_voice_hortense()
        
        print("\n‚úÖ Le programme tourne en arri√®re-plan...")
        print("‚è∏Ô∏è Appuyez sur Ctrl+C pour arr√™ter\n")
        
        try:
            while self.running:
                current_time = self.get_paris_time()
                
                if self.should_announce(current_time):
                    sound_file, message = self.schedule[(current_time.hour, current_time.minute)]
                    print(f"\nüéØ [{current_time.strftime('%H:%M:%S')}] Annonce d√©clench√©e !")
                    self.make_announcement(sound_file, message)
                
                # V√©rifier toutes les 5 secondes
                time.sleep(5)
                
        except KeyboardInterrupt:
            print("\nüõë Arr√™t du programme demand√©...")
        except Exception as e:
            print(f"‚ùå Erreur inattendue : {e}")
        finally:
            self.running = False
            # Signal d'arr√™t pour le worker
            self.announcement_queue.put(None)
    
    def __del__(self):
        """Nettoyage"""
        self.running = False
        if hasattr(self, 'engine'):
            try:
                self.engine.stop()
            except:
                pass

if __name__ == "__main__":
    # V√©rification des d√©pendances
    try:
        import pyttsx3
        import winsound
    except ImportError as e:
        print(f"‚ùå D√©pendance manquante : {e}")
        print("üí° Installez avec : pip install pyttsx3")
        exit(1)
    
    # Lancement du programme
    notifier = SessionNotifier()
    notifier.run()